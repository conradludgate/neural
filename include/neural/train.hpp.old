#pragma once

#include "neural/net.hpp"
#include <array>
#include <vector>
#include <iostream>

namespace neural
{

using ui = std::uint32_t;

template<ui A, ui B>
struct TestData
{
	Eigen::Matrix<float, A, 1> input;
	Eigen::Matrix<float, B, 1> expected;
};

template <ui A, ui B, ui... Is>
auto make_test_data()
{   
    if constexpr(sizeof...(Is) == 0)
    {
        return TestData<A, B>{};
    }
    else
    {
        return make_test_data<A, Is...>();
    }
}

template<ui First, ui Second, ui... Further>
class Trainer: public Net<First, Second, Further...>
{
public:
	virtual std::vector<decltype(make_test_data<First, Second, Further...>())> dataf(ui n) = 0;

	virtual float costf(decltype(make_test_data<First, Second, Further...>().expected) output,
		decltype(make_test_data<First, Second, Further...>().expected) expected)
	{
		auto diff = expected - output;
		return diff.dot(diff);
	}

	float test(std::vector<decltype(make_test_data<First, Second, Further...>())>& td)
	{
		double sum = 0;

		//#pragma omp parallel for
		for (int i = 0; i < td.size(); i++)
			sum += costf(this->process(td[i].input), td[i].expected);

		return sum / td.size();
	}

	void train(float tol, float p, ui n)
	{
		auto td = dataf(n);
		auto cost = test(td);

		while (cost > tol)
		{
			std::cout << cost << std::endl;

			decltype(make_matrix_tuple<First, Second, Further...>()) new_weights;

			calc_new_weights<0, First, Second, Further...>(td, new_weights, cost, p);

			//this->m_weights = new_weights;
			update_weights<sizeof...(Further)>(new_weights);

			cost = test(td);
			td = dataf(n);
		}
	}

protected:
	template<ui n, ui A, ui B, ui... Is>
	void calc_new_weights(std::vector<decltype(make_test_data<First, Second, Further...>())>& td, decltype(make_matrix_tuple<First, Second, Further...>())& new_weights, float cost, float delta)
	{
		auto m_weight_n = std::get<n>(this->m_weights);
		auto new_weight_n = std::get<n>(new_weights);

		for (int i = 0; i < A * B; i++)
		{
			m_weight_n.array()[i] += delta;
			new_weight_n.array()[i] = (cost - test(td)) * delta;
			//std::cout << new_weight_n.array()[i] << std::endl;
			m_weight_n.array()[i] -= delta;
		}

		if constexpr(sizeof...(Is) != 0)
		{
			calc_new_weights<n + 1, B, Is...>(td, new_weights, cost, delta);
		}
	}

	template<ui n>
	void update_weights(decltype(make_matrix_tuple<First, Second, Further...>())& new_weights)
	{
		std::get<n>(this->m_weights) += std::get<n>(new_weights);

		if constexpr(n > 0)
		{
			update_weights<n-1>(new_weights);
		}
	}
};
	
}